<!DOCTYPE html>
<html>
<head>
    <title>Meme Ninja</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <script src="https://unpkg.com/howler@2.2.4/dist/howler.min.js"></script>
    <style>
        html, body {
            margin: 0;
            overflow: hidden;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-color: rgb(20, 20, 20);
            height: 100vh;
            width: 100vw;
            touch-action: none; /* Prevent default touch actions like pinch-to-zoom */
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            width: 100%;
            height: 100%;
        }
        #startMenu, #gameOverScreen, #levelCompleteScreen, #scoreLevelBox, #tapToStartScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            z-index: 10;
        }
        #startMenu {
            transform: translate(-50%, -50%) scale(1.5);
            transform-origin: center;
            color: rgb(255, 215, 0);
            padding: 30px;
            border-radius: 15px;
        }
        #startMenu h1 {
            margin: 0 0 15px 0;
            font-family: 'Impact', sans-serif;
            font-size: 48px;
            color: #FFCB2F;
            text-transform: uppercase;
        }
        #startMenu p {
            margin: 0 0 20px 0;
            font-family: 'Montserrat', sans-serif;
            font-weight: bold;
            font-size: 20px;
        }
        #startMenu ul {
            text-align: left;
            display: inline-block;
            margin: 0 0 20px 0;
            padding-left: 20px;
            font-family: 'Montserrat', sans-serif;
            font-size: 16px;
            color: rgb(255, 215, 0);
        }
        #startMenu li {
            margin-bottom: 10px;
            line-height: 1.4;
        }
        #startMenu button {
            padding: 12px 24px;
            font-size: 20px;
            font-family: 'Arial Black', sans-serif;
            color: rgb(218, 165, 32);
            background-color: rgb(255, 215, 0);
            border: 2px solid rgb(218, 165, 32);
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, color 0.3s;
            touch-action: none;
            margin: 5px;
        }
        #startMenu button:hover {
            background-color: rgb(218, 165, 32);
            color: rgb(255, 215, 0);
        }
        #gameOverScreen, #levelCompleteScreen {
            transform: translate(-50%, -50%) scale(1.5);
            transform-origin: center;
            color: rgb(255, 215, 0);
            padding: 30px;
            border-radius: 15px;
        }
        #gameOverScreen h1, #levelCompleteScreen h1 {
            margin: 0 0 15px 0;
            font-family: 'Impact', sans-serif;
            font-size: 48px;
            color: rgb(218, 165, 32);
            text-transform: uppercase;
        }
        #gameOverScreen p, #levelCompleteScreen p {
            margin: 0 0 20px 0;
            font-family: 'Montserrat', sans-serif;
            font-weight: bold;
            font-size: 20px;
        }
        #gameOverScreen button, #levelCompleteScreen button {
            padding: 12px 24px;
            font-size: 20px;
            font-family: 'Arial Black', sans-serif;
            color: rgb(218, 165, 32);
            background-color: rgb(255, 215, 0);
            border: 2px solid rgb(218, 165, 32);
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, color 0.3s;
        }
        #gameOverScreen button:hover, #levelCompleteScreen button:hover {
            background-color: rgb(218, 165, 32);
            color: rgb(255, 215, 0);
        }
        #scoreLevelBox {
            top: 10px;
            left: 10px;
            transform: none;
            text-align: left;
        }
        #scoreLevelBox p {
            margin: 0 0 10px 0;
        }
        #scoreLevelBox p:last-child {
            margin: 0;
        }
        #tapToStartScreen {
            transform: translate(-50%, -50%) scale(1.5);
            transform-origin: center;
            color: rgb(255, 215, 0);
            padding: 30px;
            border-radius: 15px;
            z-index: 20;
        }
        #tapToStartScreen h1 {
            margin: 0 0 15px 0;
            font-family: 'Impact', sans-serif;
            font-size: 48px;
            color: #FFCB2F;
            text-transform: uppercase;
        }
        #tapToStartScreen p {
            margin: 0 0 20px 0;
            font-family: 'Montserrat', sans-serif;
            font-weight: bold;
            font-size: 20px;
            cursor: pointer;
        }
        #volumeIcon {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 30px;
            height: 30px;
            background-size: contain;
            background-repeat: no-repeat;
            cursor: pointer;
            z-index: 1000; /* Ensure it‚Äôs clickable */
        }
        @media only screen and (max-width: 768px) {
            #startMenu {
                transform: translate(-50%, -50%) scale(1.0);
                padding: 15px;
            }
            #startMenu h1 {
                font-size: 36px;
            }
            #startMenu p {
                font-size: 16px;
            }
            #startMenu ul {
                font-size: 14px;
            }
            #startMenu button {
                padding: 10px 20px;
                font-size: 16px;
            }
            #gameOverScreen, #levelCompleteScreen {
                transform: translate(-50%, -50%) scale(1.0);
                padding: 15px;
            }
            #gameOverScreen h1, #levelCompleteScreen h1 {
                font-size: 32px;
            }
            #gameOverScreen p, #levelCompleteScreen p {
                font-size: 14px;
            }
            #gameOverScreen button, #levelCompleteScreen button {
                padding: 8px 16px;
                font-size: 14px;
            }
            #scoreLevelBox {
                top: 5px;
                left: 5px;
                padding: 5px;
            }
            #scoreLevelBox p {
                font-size: 12px;
            }
            #tapToStartScreen {
                transform: translate(-50%, -50%) scale(1.0);
                padding: 15px;
            }
            #tapToStartScreen h1 {
                font-size: 36px;
            }
            #tapToStartScreen p {
                font-size: 16px;
            }
            #volumeIcon {
                width: 24px;
                height: 24px;
                bottom: 5px;
                left: 5px;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="scoreLevelBox" style="display: none;">
        <p>Score: <span id="scoreDisplay">0</span></p>
        <p>Level: <span id="levelDisplay">1</span></p>
    </div>

    <div id="tapToStartScreen">
        <h1>Meme Ninja</h1>
        <p>Tap to Start</p>
    </div>

    <div id="startMenu" style="display: none;">
        <h1>Meme Ninja</h1>
        <p>Instructions:</p>
        <ul>
            <li>You're getting <b>REKT</b> out here!!! Cut your losses by slicing through the memecoins.</li>
            <li>Earn 10 points and restore some capital with each slice. DIVORCE YOUR BAGS, FREN.</li>
            <li>If your capital runs out...ü§∑‚Äç‚ôÇÔ∏è life has dreams, each is wonderful.</li>
        </ul>
        <button id="startButton">Start Game</button>
    </div>

    <div id="gameOverScreen" style="display: none;">
        <h1>Game Over!</h1>
        <p>Score: <span id="finalScore">0</span></p>
        <p>Mistakes were made in a wallet you control.</p>
        <button id="restartButtonGameOver">Restart</button>
        <button id="mainMenuButton">Main Menu</button>
    </div>

    <div id="levelCompleteScreen" style="display: none;">
        <h1>Level <span id="currentLevel">1</span> Complete!</h1>
        <p>Score: <span id="currentScore">0</span></p>
        <p>Bonus (5 pts per 2nd slice): <span id="bonusScore">0</span></p>
        <button id="continueButton">Continue</button>
        <button id="restartButtonLevelComplete">Restart</button>
    </div>

    <div id="volumeIcon" style="background-image: url('Assets/volume-on.png');"></div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startMenu = document.getElementById('startMenu');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScore = document.getElementById('finalScore');
        const levelCompleteScreen = document.getElementById('levelCompleteScreen');
        const currentLevelElement = document.getElementById('currentLevel');
        const currentScoreElement = document.getElementById('currentScore');
        const bonusScoreElement = document.getElementById('bonusScore');
        const scoreLevelBox = document.getElementById('scoreLevelBox');
        const tapToStartScreen = document.getElementById('tapToStartScreen');
        const volumeIcon = document.getElementById('volumeIcon');
        const startButton = document.getElementById('startButton');
        const continueButton = document.getElementById('continueButton');
        const restartButtonLevelComplete = document.getElementById('restartButtonLevelComplete');
        const restartButtonGameOver = document.getElementById('restartButtonGameOver');
        const mainMenuButton = document.getElementById('mainMenuButton');

        let score = 0;
        let level = 1;
        let gameOver = false;
        let levelComplete = false;
        let slicedHalves = 0;
        let fruits = [];
        let fruitHalves = [];
        let swipePath = [];
        let isMuted = false;
        let playedLevelCompleteSounds = []; // Track played level complete sounds in a session
        let playedGameOverSounds = []; // Track played game over sounds in a session

        // Check if Howler.js is loaded
        if (typeof Howl === 'undefined') {
            console.error('Howler.js failed to load. Audio features will be disabled.');
        } else {
            // Force HTML5 Audio for better mobile compatibility
            Howler.html5 = true;
        }

        // Initialize the soundtrack (Assuming it stays on Glitch or you need to add its path)
        // If soundtrack is local, update path like: src: ['Assets/Sounds/Soundtrack.mp3']
        const soundtrack = typeof Howl !== 'undefined' ? new Howl({
            src: ['Assets/Soundtrack.mp3'], // UPDATE THIS if soundtrack is local
            preload: true,
            loop: true,
            volume: 0.5, // 50% volume
            onload: () => {
                console.log('Soundtrack loaded');
            },
            onloaderror: (id, error) => console.error('Failed to load soundtrack:', error)
        }) : null;

        // Initialize Howl instances for swipe sounds
        const swipeSounds = typeof Howl !== 'undefined' ? [
            new Howl({
                src: ['Assets/Swipe/swipe1.mp3'],
                preload: true,
                onload: () => console.log('Swipe sound 1 loaded'),
                onloaderror: (id, error) => console.error('Failed to load swipe sound 1:', error)
            }),
            new Howl({
                src: ['Assets/Swipe/swipe3.mp3'],
                preload: true,
                onload: () => console.log('Swipe sound 2 loaded'),
                onloaderror: (id, error) => console.error('Failed to load swipe sound 2:', error)
            })
        ] : [];

        // Initialize Howl instances for level complete sounds
        const levelCompleteSounds = typeof Howl !== 'undefined' ? [
            new Howl({
                src: ['Assets/Levelcomplete/levelcomplete1.mp3'],
                preload: true,
                onload: () => console.log('Level complete sound 1 loaded'),
                onloaderror: (id, error) => console.error('Failed to load level complete sound 1:', error)
            }),
            new Howl({
                src: ['Assets/Levelcomplete/levelcomplete2.mp3'],
                preload: true,
                onload: () => console.log('Level complete sound 2 loaded'),
                onloaderror: (id, error) => console.error('Failed to load level complete sound 2:', error)
            }),
            new Howl({
                src: ['Assets/Levelcomplete/levelcomplete3.mp3'],
                preload: true,
                onload: () => console.log('Level complete sound 3 loaded'),
                onloaderror: (id, error) => console.error('Failed to load level complete sound 3:', error)
            }),
            new Howl({
                src: ['Assets/Levelcomplete/levelcomplete4.mp3'],
                preload: true,
                onload: () => console.log('Level complete sound 4 loaded'),
                onloaderror: (id, error) => console.error('Failed to load level complete sound 4:', error)
            }),
            new Howl({
                src: ['Assets/Levelcomplete/levelcomplete5.mp3'],
                preload: true,
                onload: () => console.log('Level complete sound 5 loaded'),
                onloaderror: (id, error) => console.error('Failed to load level complete sound 5:', error)
            }),
            new Howl({
                src: ['Assets/Levelcomplete/levelcomplete6.mp3'],
                preload: true,
                onload: () => console.log('Level complete sound 6 loaded'),
                onloaderror: (id, error) => console.error('Failed to load level complete sound 6:', error)
            })
        ] : [];

        // Initialize Howl instances for start game sounds
        const startGameSounds = typeof Howl !== 'undefined' ? [
            new Howl({
                src: ['Assets/Start or Restart/Welcome.mp3'],
                preload: true,
                onload: () => console.log('Start game sound 1 loaded'),
                onloaderror: (id, error) => console.error('Failed to load start game sound 1:', error)
            }),
            new Howl({
                src: ['Assets/Start or Restart/introsendmoney.mp3'],
                preload: true,
                onload: () => console.log('Start game sound 2 loaded'),
                onloaderror: (id, error) => console.error('Failed to load start game sound 2:', error)
            })
        ] : [];

        // Initialize Howl instances for restart game sounds
        const restartGameSounds = typeof Howl !== 'undefined' ? [
            new Howl({
                src: ['Assets/Start or Restart/rugged.mp3'],
                preload: true,
                onload: () => console.log('Restart game sound 1 loaded'),
                onloaderror: (id, error) => console.error('Failed to load restart game sound 1:', error)
            }),
            new Howl({
                src: ['Assets/Start or Restart/MemeNinja.mp3'],
                preload: true,
                onload: () => console.log('Restart game sound 2 loaded'),
                onloaderror: (id, error) => console.error('Failed to load restart game sound 2:', error)
            })
        ] : [];

        // Initialize Howl instances for game over sounds
        const gameOverSounds = typeof Howl !== 'undefined' ? [
            new Howl({
                src: ['Assets/Game Over/gameover1.mp3'],
                preload: true,
                onload: () => console.log('Game over sound 1 loaded'),
                onloaderror: (id, error) => console.error('Failed to load game over sound 1:', error)
            }),
            new Howl({
                src: ['Assets/Game Over/gameover2.mp3'],
                preload: true,
                onload: () => console.log('Game over sound 2 loaded'),
                onloaderror: (id, error) => console.error('Failed to load game over sound 2:', error)
            }),
            new Howl({
                src: ['Assets/Game Over/gameover3.mp3'],
                preload: true,
                onload: () => console.log('Game over sound 3 loaded'),
                onloaderror: (id, error) => console.error('Failed to load game over sound 3:', error)
            }),
            new Howl({
                src: ['Assets/Game Over/gameover4.mp3'],
                preload: true,
                onload: () => console.log('Game over sound 4 loaded'),
                onloaderror: (id, error) => console.error('Failed to load game over sound 4:', error)
            }),
            new Howl({
                src: ['Assets/Game Over/gameover5.mp3'],
                preload: true,
                onload: () => console.log('Game over sound 5 loaded'),
                onloaderror: (id, error) => console.error('Failed to load game over sound 5:', error)
            }),
            new Howl({
                src: ['Assets/Game Over/gameover6.mp3'],
                preload: true,
                onload: () => console.log('Game over sound 6 loaded'),
                onloaderror: (id, error) => console.error('Failed to load game over sound 6:', error)
            }),
            new Howl({
                src: ['Assets/Game Over/gameover7.mp3'],
                preload: true,
                onload: () => console.log('Game over sound 7 loaded'),
                onloaderror: (id, error) => console.error('Failed to load game over sound 7:', error)
            })
        ] : [];

        function playRandomSwipeSound() {
            if (isMuted || swipeSounds.length === 0) {
                console.warn('Swipe sound not played: Muted or no sounds available');
                return;
            }
            try {
                console.log('Attempting to play a swipe sound');
                const randomIndex = Math.floor(Math.random() * swipeSounds.length);
                const sound = swipeSounds[randomIndex];
                sound.play();
                console.log('Swipe sound played:', randomIndex);
            } catch (error) {
                console.error('Error playing swipe sound:', error);
            }
        }

        function playRandomLevelCompleteSound() {
            if (isMuted || levelCompleteSounds.length === 0) {
                console.warn('Level complete sound not played: Muted or no sounds available');
                return;
            }
            try {
                console.log('Attempting to play a level complete sound');

                // Create a list of available sound indices that haven't been played
                let availableIndices = [];
                for (let i = 0; i < levelCompleteSounds.length; i++) {
                    if (!playedLevelCompleteSounds.includes(i)) {
                        availableIndices.push(i);
                    }
                }

                // If all sounds have been played, reset the list
                if (availableIndices.length === 0) {
                    playedLevelCompleteSounds = [];
                    availableIndices = Array.from({ length: levelCompleteSounds.length }, (_, i) => i);
                }

                // Pick a random index from the available ones
                const randomIndex = availableIndices[Math.floor(Math.random() * availableIndices.length)];
                playedLevelCompleteSounds.push(randomIndex);

                const sound = levelCompleteSounds[randomIndex];
                sound.play();
                console.log('Level complete sound played:', randomIndex);
            } catch (error) {
                console.error('Error playing level complete sound:', error);
            }
        }

        function playRandomStartGameSound() {
            if (isMuted || startGameSounds.length === 0) {
                console.warn('Start game sound not played: Muted or no sounds available');
                return;
            }
            try {
                console.log('Attempting to play a start game sound');
                const randomIndex = Math.floor(Math.random() * startGameSounds.length);
                const sound = startGameSounds[randomIndex];
                sound.play();
                console.log('Start game sound played:', randomIndex);
            } catch (error) {
                console.error('Error playing start game sound:', error);
            }
        }

        function playRandomRestartGameSound() {
            if (isMuted || restartGameSounds.length === 0) {
                console.warn('Restart game sound not played: Muted or no sounds available');
                return;
            }
            try {
                console.log('Attempting to play a restart game sound');
                const randomIndex = Math.floor(Math.random() * restartGameSounds.length);
                const sound = restartGameSounds[randomIndex];
                sound.play();
                console.log('Restart game sound played:', randomIndex);
            } catch (error) {
                console.error('Error playing restart game sound:', error);
            }
        }

        function playRandomGameOverSound() {
            if (isMuted || gameOverSounds.length === 0) {
                console.warn('Game over sound not played: Muted or no sounds available');
                return;
            }
            try {
                console.log('Attempting to play a game over sound');

                // Create a list of available sound indices that haven't been played
                let availableIndices = [];
                for (let i = 0; i < gameOverSounds.length; i++) {
                    if (!playedGameOverSounds.includes(i)) {
                        availableIndices.push(i);
                    }
                }

                // If all sounds have been played, reset the list
                if (availableIndices.length === 0) {
                    playedGameOverSounds = [];
                    availableIndices = Array.from({ length: gameOverSounds.length }, (_, i) => i);
                }

                // Pick a random index from the available ones
                const randomIndex = availableIndices[Math.floor(Math.random() * availableIndices.length)];
                playedGameOverSounds.push(randomIndex);

                const sound = gameOverSounds[randomIndex];
                sound.play();
                console.log('Game over sound played:', randomIndex);
            } catch (error) {
                console.error('Error playing game over sound:', error);
            }
        }

        // Toggle mute/unmute for all sounds
        function toggleMute() {
            console.log('toggleMute called');
            isMuted = !isMuted;
            if (isMuted) {
                Howler.mute(true);
                volumeIcon.style.backgroundImage = "url('Assets/volume-off.png')"; // Updated path
            } else {
                Howler.mute(false);
                volumeIcon.style.backgroundImage = "url('Assets/volume-on.png')"; // Updated path
            }
            console.log('Sound muted:', isMuted);
        }

        // Add click/touch event listener for the volume icon
        volumeIcon.addEventListener('click', (e) => {
            e.preventDefault();
            toggleMute();
        });
        volumeIcon.addEventListener('touchstart', (e) => {
            e.preventDefault();
            toggleMute();
        });

        const MEMECOIN_TICKERS = [
            "DOGE", "SHIB", "PEPE", "WIF", "BONK", "FLOKI", "BRETT", "MEME", "TRUMP", "POPCAT",
            "MOG", "TURBO", "GIGA", "SPX", "DEGEN", "ai16z", "BITCOIN", "ELON", "SAMO", "SIGMA",
            "KISHU", "AKITA", "HOGE", "TOSHI", "BOME", "NEIRO", "JUP", "MOODENG", "HAWK", "PNUT",
            "BANANA", "SLERF", "MEW", "CORGIAI", "SHIT", "FARTCOIN", "MILO", "KEYCAT", "GOAT", "MIGGLES",
            "SKI", "BENJI", "MOCHI", "DOGINME", "UFD", "REKT", "SKIBIDI", "MOTHER", "NYAN", "GRUMPY",
            "TOKYO", "PUG", "CHIBA", "BORK", "CHEESE", "DINU", "CHONKY", "WEN", "PAW", "SNEK", "MYRO",
            "JAILSTOOL", "BALD", "ZACK", "DINO", "KANGAL", "HUSKY", "BULL", "CAT", "RFD", "GME", "AMC",
            "BOBO", "FREN", "SMILYmeasurements", "ANALOS", "LADYS", "POOH", "ZEREBRO", "VINU", "LEASH", "XAI", "SAFEMOON",
            "PIG", "KIBA", "DOBO", "FLOKITA", "SEILOR", "WOOF", "COQ", "HAMI", "DOGGY", "PONKE",
            "PENG", "SCREAM", "BAN", "PWEASE", "MONA", "GOVAI", "GREED2"
        ];

        let life = 100;
        const LIFE_BAR_WIDTH = 200;
        const LIFE_BAR_HEIGHT = 20;
        let LIFE_DEPLETION_RATE = 0.05;
        const LIFE_GAIN_PER_FRUIT = 10;

        const GRAVITY = 0.15;
        const MAX_HORIZONTAL_VELOCITY = 3;
        const MAX_SWIPE_LENGTH = 200;

        // Background images kept as external URLs per request
        const BACKGROUND_IMAGES = [
            'https://pbs.twimg.com/media/GRkzW4hbAAAefJk.jpg',
            'https://i.pinimg.com/474x/3e/28/b8/3e28b8269ddb5c77466f993c1620bf28.jpg',
            'https://motivatingdaily.com/wp-content/uploads/2013/01/endurance.jpg?w=584',
            'https://media.npr.org/assets/img/2016/09/01/narcos_203_00873r1_wide-85dd278b73b9b27e5ec91b5d5e63be31df849d39.jpg',
            'https://i.insider.com/6127fca280be940019b9de4c?width=792&format=jpeg',
            'https://i.kym-cdn.com/entries/icons/original/000/023/077/Leo_Toasting_meme_banner.jpg',
            'https://images.wsj.net/im-06281483?width=700&height=389',
            'https://pbs.twimg.com/profile_banners/1853579246150553600/1741103526/1500x500',
            'https://i.ytimg.com/vi/EmW74ZpGGOI/maxresdefault.jpg'
        ];

        function setRandomBackground() {
            const randomIndex = Math.floor(Math.random() * BACKGROUND_IMAGES.length);
            document.body.style.backgroundImage = `url('${BACKGROUND_IMAGES[randomIndex]}')`;
        }
        setRandomBackground();

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        class Fruit {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = canvas.height;
                this.radius = 33 + Math.random() * 100;
                this.velocityY = 7 + Math.random() * 15;
                this.velocityX = (Math.random() - 0.5) * MAX_HORIZONTAL_VELOCITY * 2;
                this.rotation = 0;
                this.ticker = MEMECOIN_TICKERS[Math.floor(Math.random() * MEMECOIN_TICKERS.length)];
            }

            update() {
                this.velocityY -= GRAVITY;
                this.x += this.velocityX;
                this.y -= this.velocityY;
                this.rotation += 0.1;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                ctx.fillStyle = 'rgb(255, 215, 0)';
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = 'rgb(218, 165, 32)';
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 0.9, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = 'rgb(255, 215, 0)';
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 0.8, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = 'rgb(218, 165, 32)';
                const textSize = this.ticker.length <= 5 ? Math.max(10, this.radius * 0.4) : Math.max(10, this.radius * 0.25);
                ctx.font = `${textSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.ticker, 0, 0);

                ctx.restore();
            }
        }

        class FruitHalf {
            constructor(x, y, radius, angle, splittable = false, type = "half") {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.angle = angle;
                this.velocityX = Math.cos(angle) * 5;
                this.velocityY = Math.sin(angle) * -5;
                this.rotation = 0;
                this.splittable = splittable;
                this.type = type;
                this.percentage = type === "half" ?
                    Math.floor(Math.random() * (75 - 50 + 1)) + 50 :
                    Math.floor(Math.random() * (99 - 76 + 1)) + 76;
            }

            update() {
                this.velocityY += GRAVITY;
                this.x += this.velocityX;
                this.y += this.velocityY;
                this.rotation += 0.1;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.fillStyle = '#E72C1E';
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fill();
                const fontSize = Math.max(10, this.radius - 8);
                ctx.font = `${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = 'white';
                ctx.fillText(`-${this.percentage}%`, 0, 0);
                ctx.restore();
            }
        }

        function drawLifeBar() {
            const lifeBarX = canvas.width - LIFE_BAR_WIDTH - 20;
            const lifeBarY = 20;
            ctx.fillStyle = 'black';
            ctx.fillRect(lifeBarX, lifeBarY, LIFE_BAR_WIDTH, LIFE_BAR_HEIGHT);
            ctx.fillStyle = 'green';
            ctx.fillRect(lifeBarX, lifeBarY, (life / 100) * LIFE_BAR_WIDTH, LIFE_BAR_HEIGHT);
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.strokeRect(lifeBarX, lifeBarY, LIFE_BAR_WIDTH, LIFE_BAR_HEIGHT);
        }

        // --- The rest of the game logic (gameLoop, event listeners, etc.) remains the same ---
        // --- Make sure this script block is closed properly ---
        // (Add the rest of your existing JavaScript logic here if it was cut off)

        // --- Example Placeholder for rest of the JS ---

        function updateScoreDisplay() {
            document.getElementById('scoreDisplay').textContent = score;
        }

        function updateLevelDisplay() {
            document.getElementById('levelDisplay').textContent = level;
        }

        function spawnFruit() {
            // Logic to add new Fruit() to the fruits array based on level
            if (Math.random() < 0.02 + level * 0.01) { // Example spawn rate increase
                 fruits.push(new Fruit());
             }
        }

         function gameLoop() {
             if (gameOver || levelComplete) return;

             ctx.clearRect(0, 0, canvas.width, canvas.height);

             // Update and draw fruits
             for (let i = fruits.length - 1; i >= 0; i--) {
                 fruits[i].update();
                 fruits[i].draw();
                 // Remove fruits that go off screen below
                 if (fruits[i].y > canvas.height + fruits[i].radius * 2 && fruits[i].velocityY < 0) {
                     fruits.splice(i, 1);
                     // Optionally decrease life/score for missed fruit
                 }
             }

             // Update and draw fruit halves
             for (let i = fruitHalves.length - 1; i >= 0; i--) {
                 fruitHalves[i].update();
                 fruitHalves[i].draw();
                 if (fruitHalves[i].y > canvas.height + fruitHalves[i].radius) {
                     fruitHalves.splice(i, 1);
                 }
             }

            // Draw swipe path
            if (swipePath.length > 1) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(swipePath[0].x, swipePath[0].y);
                for (let i = 1; i < swipePath.length; i++) {
                    ctx.lineTo(swipePath[i].x, swipePath[i].y);
                }
                ctx.stroke();
            }


             // Draw UI elements
             drawLifeBar();
             updateScoreDisplay(); // Ensure score/level box is visible during game
             updateLevelDisplay();

             // Decrease life
             life -= LIFE_DEPLETION_RATE;
             if (life <= 0) {
                 life = 0;
                 triggerGameOver();
             }

             // Spawn new fruits
             spawnFruit();


             requestAnimationFrame(gameLoop);
         }

        function triggerGameOver() {
            gameOver = true;
            soundtrack?.stop(); // Stop soundtrack if playing
            playRandomGameOverSound();
            finalScore.textContent = score;
            gameOverScreen.style.display = 'block';
            scoreLevelBox.style.display = 'none'; // Hide score/level box
        }

        function triggerLevelComplete() {
             levelComplete = true;
             soundtrack?.pause(); // Pause soundtrack
             // Calculate bonus score logic here based on `slicedHalves` or other metrics
             let bonus = slicedHalves * 5; // Example bonus calculation
             bonusScoreElement.textContent = bonus;
             score += bonus; // Add bonus to final score for the level
             currentLevelElement.textContent = level;
             currentScoreElement.textContent = score;
             levelCompleteScreen.style.display = 'block';
             scoreLevelBox.style.display = 'none';
             playRandomLevelCompleteSound(); // Play sound after pausing soundtrack
         }

         function resetGame() {
            score = 0;
            level = 1;
            life = 100;
            gameOver = false;
            levelComplete = false;
            slicedHalves = 0;
            fruits = [];
            fruitHalves = [];
            swipePath = [];
            updateScoreDisplay();
            updateLevelDisplay();
            gameOverScreen.style.display = 'none';
            levelCompleteScreen.style.display = 'none';
            startMenu.style.display = 'none';
            scoreLevelBox.style.display = 'block'; // Show score/level box
            setRandomBackground(); // Change background on reset/start
            if (!isMuted && soundtrack && !soundtrack.playing()) {
               soundtrack.play(); // Resume or start soundtrack
            }
        }

         function startGame() {
             resetGame();
             playRandomStartGameSound();
             gameLoop();
         }

        function continueGame() {
            level++;
            levelComplete = false;
            // Reset for next level
            fruits = [];
            fruitHalves = [];
            swipePath = [];
            slicedHalves = 0; // Reset bonus counter for next level
            LIFE_DEPLETION_RATE += 0.01; // Increase difficulty slightly
            levelCompleteScreen.style.display = 'none';
            scoreLevelBox.style.display = 'block';
             if (!isMuted && soundtrack && !soundtrack.playing()) {
               soundtrack.play(); // Resume soundtrack
             }
            gameLoop();
         }

         // Event Listeners (Mouse / Touch)
         let isSwiping = false;

         function handleStart(event) {
             event.preventDefault(); // Prevent default touch behavior (like scrolling)
             isSwiping = true;
             swipePath = []; // Start new path
             const pos = getEventPosition(event);
             if (pos) swipePath.push(pos);
         }

         function handleMove(event) {
             event.preventDefault();
             if (!isSwiping) return;
             const pos = getEventPosition(event);
             if (pos) {
                swipePath.push(pos);
                // Keep swipe path from getting too long
                if (swipePath.length > MAX_SWIPE_LENGTH) {
                    swipePath.shift(); // Remove the oldest point
                }
                checkSlice();
             }
         }

         function handleEnd(event) {
             event.preventDefault();
             if (!isSwiping) return;
             isSwiping = false;
            // Optional: Clear swipe path visually after a short delay
             setTimeout(() => { swipePath = []; }, 100);
         }

        function getEventPosition(event) {
             if (event.touches && event.touches.length > 0) {
                 // Touch event
                 return { x: event.touches[0].clientX, y: event.touches[0].clientY };
             } else if (event.clientX !== undefined && event.clientY !== undefined) {
                 // Mouse event
                 return { x: event.clientX, y: event.clientY };
             }
             return null; // Return null if position cannot be determined
         }

         function checkSlice() {
             if (swipePath.length < 2) return; // Need at least two points for a line segment

             const lastPoint = swipePath[swipePath.length - 1];
             const prevPoint = swipePath[swipePath.length - 2];

             for (let i = fruits.length - 1; i >= 0; i--) {
                 const fruit = fruits[i];
                 // Simple collision check: distance from fruit center to line segment
                 const dist = pointSegmentDistance(fruit.x, fruit.y, prevPoint.x, prevPoint.y, lastPoint.x, lastPoint.y);

                 if (dist < fruit.radius) {
                     sliceFruit(i, lastPoint); // Pass the slice point
                     playRandomSwipeSound(); // Play sound on slice
                     break; // Slice one fruit per check for simplicity
                 }
             }
         }

          // Helper function for distance between point and line segment
         function pointSegmentDistance(px, py, x1, y1, x2, y2) {
             const l2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
             if (l2 === 0) return Math.sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1));
             let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2;
             t = Math.max(0, Math.min(1, t));
             const projX = x1 + t * (x2 - x1);
             const projY = y1 + t * (y2 - y1);
             return Math.sqrt((px - projX) * (px - projX) + (py - projY) * (py - projY));
         }


         function sliceFruit(index, slicePoint) {
             const fruit = fruits[index];

             // Calculate angle roughly based on swipe direction (optional, simple split for now)
             const angle1 = Math.random() * Math.PI * 2;
             const angle2 = angle1 + Math.PI;

             // Create two halves
             fruitHalves.push(new FruitHalf(fruit.x, fruit.y, fruit.radius / 1.5, angle1, false, "half"));
             fruitHalves.push(new FruitHalf(fruit.x, fruit.y, fruit.radius / 1.5, angle2, false, "quarter")); // Second one is a "quarter" for scoring

             fruits.splice(index, 1); // Remove original fruit

             // Update score and life
             score += 10;
             life += LIFE_GAIN_PER_FRUIT;
             life = Math.min(life, 100); // Cap life at 100
             slicedHalves++; // Increment for bonus calculation

             updateScoreDisplay();

             // Check for level completion (example: score threshold)
             if (score >= level * 50) { // Example: 50 points per level
                  triggerLevelComplete();
              }
         }


         // Initial Setup & Button Listeners
         canvas.addEventListener('mousedown', handleStart);
         canvas.addEventListener('mousemove', handleMove);
         canvas.addEventListener('mouseup', handleEnd);
         canvas.addEventListener('mouseleave', handleEnd); // Stop swipe if mouse leaves canvas

         canvas.addEventListener('touchstart', handleStart, { passive: false });
         canvas.addEventListener('touchmove', handleMove, { passive: false });
         canvas.addEventListener('touchend', handleEnd);
         canvas.addEventListener('touchcancel', handleEnd);


         startButton.addEventListener('click', () => {
             startMenu.style.display = 'none';
             startGame();
         });
         startButton.addEventListener('touchstart', (e) => {
            e.preventDefault(); // prevent click event firing too
             startMenu.style.display = 'none';
             startGame();
         });


        continueButton.addEventListener('click', continueGame);
        continueButton.addEventListener('touchstart', (e) => { e.preventDefault(); continueGame(); });


        restartButtonLevelComplete.addEventListener('click', startGame);
        restartButtonLevelComplete.addEventListener('touchstart', (e) => { e.preventDefault(); startGame(); });


        restartButtonGameOver.addEventListener('click', startGame);
        restartButtonGameOver.addEventListener('touchstart', (e) => { e.preventDefault(); startGame(); });


        mainMenuButton.addEventListener('click', () => {
            gameOverScreen.style.display = 'none';
            startMenu.style.display = 'block';
            resetGame(); // Reset score etc. but don't start loop
             soundtrack?.stop(); // Make sure soundtrack is stopped
            scoreLevelBox.style.display = 'none'; // Hide score box on main menu
         });
         mainMenuButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
             gameOverScreen.style.display = 'none';
             startMenu.style.display = 'block';
             resetGame();
             soundtrack?.stop();
             scoreLevelBox.style.display = 'none';
         });


         tapToStartScreen.addEventListener('click', () => {
             tapToStartScreen.style.display = 'none';
             startMenu.style.display = 'block';
             // Preload/prepare audio context on user interaction
              if (Howler.ctx && Howler.ctx.state === 'suspended') {
                  Howler.ctx.resume();
              }
              // Attempt to play and immediately pause/stop a silent sound to unlock audio
              const silentSound = new Howl({ src: ['data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA'], volume: 0 });
              silentSound.play();
              // Maybe stop is better than pause
              setTimeout(() => silentSound.stop(), 10);
         });
          tapToStartScreen.addEventListener('touchstart', (e) => {
            e.preventDefault();
             tapToStartScreen.style.display = 'none';
             startMenu.style.display = 'block';
              // Preload/prepare audio context on user interaction
              if (Howler.ctx && Howler.ctx.state === 'suspended') {
                  Howler.ctx.resume();
              }
               // Attempt to play and immediately pause/stop a silent sound to unlock audio
               const silentSound = new Howl({ src: ['data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA'], volume: 0 });
               silentSound.play();
               setTimeout(() => silentSound.stop(), 10);
         });

        // Ensure initial state is correct
        scoreLevelBox.style.display = 'none'; // Hide score box initially
        gameOverScreen.style.display = 'none';
        levelCompleteScreen.style.display = 'none';
        startMenu.style.display = 'none'; // Start with tap-to-start


    </script>
</body>
</html>
